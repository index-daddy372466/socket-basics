<script>
  const textinput = document.getElementById('text-input')
  // const socket = io()
  // set tile positions
  window.onload = async (e) => {
    textinput.focus();
    let copy,sugar
    if(window.innerWidth <= 650){
      copy = [...tiles].slice(1,[...tiles].length)
    }
    else{
      copy = [...tiles]
    }
    tiles = [...copy].map((t, index) => {
      t.style.width = `${document.body.clientWidth / copy.length}px`;
      t.style.left = `${(document.body.clientWidth / copy.length) * index}px`;
    });

    // get exisitng rooms
    // fetch existing
    let existing = await fetch("/rooms/existing")
      .then((r) => r.json())
      .then((d) => d.room);
    if (existing !== "no data") {
      existing.map((ex) => inTake(ex));
    }
  }

  let intake = document.getElementById("intake");
  let tiles = [...document.querySelectorAll(".tile")]
  let sx = 0,
    sy = 0,
    nx = 0,
    ny = 0;
  // iterate through tiles
  tiles.forEach((tile, idx) => {
    tile.onmousedown = mouseDown;
    

    //1) Mousedown
    function mouseDown(e) {
      // starting position becomes current tile position
      sx = e.clientX;
      sy = e.clientY;
    
      // listen for mousemove & mouseup events when mouse is down
      document.addEventListener("mousemove", mouseMove);
      document.onmouseup = mouseUp;
    }

    // mousemove
    function mouseMove(e) {
      // new x/y positions = starting positions - current tile position
      nx = sx - e.clientX;
      ny = sy - e.clientY;

      // starting position becomes current tile position (again)
      sx = e.clientX;
      sy = e.clientY;

      // tile's left position = tile's left offset - new-x position
      tile.style.left = `${tile.offsetLeft - nx}px`;
      // tile's top position = tile's top offset - new-y position
      tile.style.top = `${tile.offsetTop - ny}px`;
    }

    // mouseup
    function mouseUp(e) {
      // remove mousemove event listener
      document.removeEventListener("mousemove", mouseMove);
    }
  });

  let room_intake = tiles[1];
  let sameCreator =  false;
  // submit function
  let submit = document.querySelector("button[type=submit]");
  submit.onclick = async (e) => {
    // prevent form from firing
    e.preventDefault();

    console.log(
      await checkCurseWords(e.target.parentElement.children[0].value)
    );
    let value =
      (await checkCurseWords(e.target.parentElement.children[0].value)) == false
        ? e.target.parentElement.children[0].value
        : false;
    console.log(value);
    let payload = { room: value };
    // create new room
    await fetch("/room/create", {
      headers: { "Content-Type": "application/json" },
      method: "POST",
      body: JSON.stringify(payload),
    })
      .then((r) => {
        console.log(r.status);
        return r.json();
      })
      .then((data) => {
        let rooms = data.room; // array of rooms
        let target = rooms[rooms.length - 1];
        // user/socket creates a room and sends request to the server
        // socket.emit('create_room',target);
        // server broadcasts sender's request to everyone in home page
        inTake(target);
      });
    e.target.parentElement.children[0].value = "";
  };

  let combine = [];
  // check curse words helper func
  async function checkCurseWords(val) {
    // get wiki curse words
    console.log("checking if " + val + " is a curseword...");
    let curses = await fetch("/words/curse")
      .then((r) => r.json())
      .then((d) => d.words);
    // get full length of arrays
    let len = curses.length;

    let bool = [...curses].filter((word, idx) => {
      let reg = new RegExp(`${word}`, "ig");
      return ((val=='hello') && (combine.includes(val) || reg.test(val))) || (combine.includes(val) || reg.test(val))
    });
    return bool.length > 0;
  }

  // function to append li's to ul
  function inTake(room) {
    let li = document.createElement("li");
    li.classList.add("align-li");
    li.textContent = room;
    intake.appendChild(li);
    let lis = document.querySelectorAll(".align-li");
    lis.forEach((l, index) => {
      l.onclick = async (e) => {
        let room = l.textContent;
        return await fetch("/rooms/check", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ room: room }),
        })
          .then((r) => r.json())
          .then((data) => {
            if (!data.data) {
              window.location.reload();
            } else {
              window.location.href = window.location.origin + `/room/${room}`;
            }
          });
      };
    });
  }
</script>
