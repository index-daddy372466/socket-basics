<script>
  // fetch docker api
  fetch('/numbers')
    .then((r) => r.json())
    .then((d) => console.log(d.numbers));

  let socket = io();

  // declare form & text-input
  let form = document.getElementById("form");
  let text = document.getElementById("text");
  let submit = document.getElementById("submit");
  let chatbox = document.getElementById("chats");
  let header = document.querySelector("#room-header>em");
  let keyboard = document.querySelector("svg#type-keyboard");
  let typing = false;
  let timeout = undefined;
  let typingarr = document.getElementById("typing-users");

  // fix typing array (typing indicator)
  console.log(typingarr);
  typingarr.style.bottom = text.clientHeight + 20 + "px";

  // ejs rendered variable
  const roomname = "<%= room %>";

  socket.on("connect", function () {
    // welcome message
    // client sends request to server
    socket.emit("welcome", roomname);
    socket.emit("join_room", roomname);
  });

  // show room header
  window.onload = async (e) => {
    // focus text
    text.focus();
    // send scrollbar to the last chat message + a margin
    setTimeout(
      () => chatbox.scrollTo(0, chatbox.scrollHeight - chatbox.clientHeight),
      250
    );

    let mainheader = header.parentElement;
    mainheader.classList.toggle("appear-header");

    // retrieve user's name from socket
    socket.on("get_name", async (user) => {
      console.log("get_name: ");
      console.log(user);
      // fetch for existing chats & append to chatbox
      // get existing messages
      let chats = await fetch(`/${roomname}/sec/messages`)
        .then((r) => r.json())
        .then((d) => {
          if (d.messages !== "no messages") {
            let messages = [...d.messages];
            console.log(messages);
            messages.map((msg, index) => {
              sameSender = msg["sender"] === user.name;
              let li = document.createElement("li");
              let p = document.createElement("p");
              li.classList.add("list-item");
              li.appendChild(p)
              !sameSender ? p.classList.add("p-left") : p.classList.add("p-right");
              !sameSender
                ? li.classList.add("left")
                : li.classList.add("right");
              p.textContent = li.classList.contains("right")
                ? msg.message + ` [${msg.sender}]`
                : `[${msg.sender}] ` + msg.message;
              chatbox.appendChild(li);
            });
          }
        });
    });
  };

  // user is typing to the server
  text.onkeypress = (e) => {
    if (e.which != 13) {
      typing = true;
      socket.emit("typing", roomname);
      socket.emit("keyboard", typing, roomname);
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        typing = false;
        socket.emit("typing", roomname);
        socket.emit("keyboard", typing, roomname);
      }, 2750);
    }
    let names = [];
    socket.on("typing", (name) => {
      if (names.indexOf(name) == -1) {
        names.push(name);
        console.log(names);
      }
      // set paragraph textcontent to the updated names array
      typingarr.children[0].textContent =
        names.length > 0 && names.length < 2
          ? [...names].join("") + " is typing..."
          : names.length > 1 && names.length < 3
          ? [...names].join(" and ") + " are typing..."
          : [...names].map((n,i)=>i==names.length-1 ? 'and ' + n : n).join(", ") + " are typing...";
    });
    // keyboard display
    socket.on("keyboard", (bool, name) => {
      let index = [...names].indexOf(name);
      if (bool == true) {
        typingarr.children[0].classList.remove("user-hide");
        typingarr.children[0].classList.add("user-appear");
        keyboard.classList.remove("type-hidden");
        keyboard.classList.add("type-appear");
      } else {
        if (names.indexOf(name) != -1) {
          names.splice(index, 1);
        }
        typingarr.children[0].classList.remove("user-appear");
        keyboard.classList.remove("type-appear");
        keyboard.classList.add("type-hidden");

        // set paragraph textcontent to the updated names array
        typingarr.children[0].textContent =
          names.length < 1
            ? typingarr.children[0].classList.add("user-hide")
            : names.length > 0 && names.length < 2
            ? [...names].join("") + " is typing..."
            : [...names].join(", ") + " are typing...";
      }
    });
  };
  let sameSender = false; // verify if the sender if you
  // submit onclick
  submit.onclick = (e) => {
    setTimeout(() => chatbox.scrollTo(0, 1000), 250);
    sameSender = true;
    e.preventDefault();
    if (text.value) {
      // get existing messages
      fetch(`/room/${roomname}/${text.value}`)
        .then((r) => r.json())
        .then((d) => console.log(d));
      socket.emit("public_message", text.value, roomname);
      text.value = "";
    }
  };

  // append li to chatbox
  socket.on("send_it", (msg, name) => {
    let li = document.createElement("li");
    let p = document.createElement("p");
    li.classList.add("list-item");
    li.appendChild(p)
    !sameSender ? p.classList.add("p-left") : p.classList.add("p-right");
    // once the li is created, text-align start/end based off of receiver/sender respectively
    !sameSender ? li.classList.add("left") : li.classList.add("right");
    sameSender = false;
    p.textContent = li.classList.contains("right")
      ? msg + ` [${name}]`
      : `[${name}] ` + msg;
    chatbox.appendChild(li);

    setTimeout(
      () => chatbox.scrollTo(0, chatbox.scrollHeight - chatbox.clientHeight),
      250
    );
  });
</script>
