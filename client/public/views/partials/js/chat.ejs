<script>
  // fetch docker api
  // fetch("/numbers")
  //   .then((r) => r.json())
  //   .then((d) => console.log(d.numbers));

  let socket = io();

  // declare form & text-input
  let form = document.getElementById("form");
  let text = document.getElementById("text");
  let submit = document.getElementById("submit");
  let chatbox = document.getElementById("chats");
  let header = document.querySelector("#room-header>em");
  let keyboard = document.querySelector("svg#type-keyboard");
  let typing = false;
  let timeout = undefined;
  let typingarr = document.getElementById("typing-users");

  // fix typing array (typing indicator)
  console.log(typingarr);
  typingarr.style.bottom = text.clientHeight + 20 + "px";

  // ejs rendered variable
  const roomname = "<%= room %>";

  socket.on("connect", function () {
    // welcome message
    // client sends request to server
    socket.emit("welcome", roomname);
    socket.emit("join_room", roomname);
  });

  // show room header
  window.onload = async (e) => {
    text.focus();
    let mainheader = header.parentElement;
    mainheader.classList.toggle("appear-header");

    // retrieve user's name from socket
    socket.on("get_name", async (name) => {
      // fetch for existing chats & append to chatbox
      // get existing messages
      let chats = await fetch(`/${roomname}/sec/messages`)
        .then((r) => r.json())
        .then((d) => {
          console.log(d);
          if (d.messages !== "no messages") {
            let messages = [...d.messages];
            messages.map((msg, index) => {
              sameSender = msg["sender"] === name;
              let li = document.createElement("li");
              li.classList.add("list-item");
              !sameSender
                ? li.classList.add("left")
                : li.classList.add("right");
              li.textContent = li.classList.contains("right")
                ? msg.message + ` [${msg.sender}]`
                : `[${msg.sender}] ` + msg.message;
              chatbox.appendChild(li);
            });
          }
        });
    });
  };
  let control = undefined;

  // user is typing to the server
  text.onkeypress = (e) => {
    if (e.which != 13) {
      typing = true;
      socket.emit("typing", roomname);
      socket.emit("keyboard", typing, roomname);
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        typing = false;
        socket.emit("typing", roomname);
        socket.emit("keyboard", typing, roomname);
      }, 2000);
    }
    let names = [];
    socket.on("typing", (name) => {
      if (names.indexOf(name) == -1) {
        names.push(name);
        console.log(names);
      }
      // set paragraph textcontent to the updated names array
      typingarr.children[0].textContent =
        names.length > 0 && names.length < 2
          ? [...names].join("") + " is typing..."
          : [...names].join(", ") + " are typing...";
    });
    // keyboard display
    socket.on("keyboard", (bool, name) => {
      let index = [...names].indexOf(name);
      if (bool == true) {
        typingarr.children[0].classList.remove("user-hide");
        typingarr.children[0].classList.add("user-appear");
        keyboard.classList.remove("type-hidden");
        keyboard.classList.add("type-appear");
      } else {
        if (names.indexOf(name)!=-1) {
          names.splice(index, 1);
        }
        typingarr.children[0].classList.remove("user-appear");
        keyboard.classList.remove("type-appear");
        keyboard.classList.add("type-hidden");

        // set paragraph textcontent to the updated names array
        typingarr.children[0].textContent =
          names.length < 1
            ? typingarr.children[0].classList.add('user-hide')
            : names.length > 0 && names.length < 2
            ? [...names].join("") + " is typing..."
            : [...names].join(", ") + " are typing...";
      }
    });
  };
  let sameSender = false; // verify if the sender if you
  // submit onclick
  submit.onclick = (e) => {
    // console.log("scrollHeight");
    // console.log(chatbox.scrollHeight + 100);
    chatbox.scrollTop = chatbox.scrollHeight - chatbox.clientHeight;
    setTimeout(() => chatbox.scrollTo(0, chatbox.clientHeight), 250);
    sameSender = true;
    e.preventDefault();
    if (text.value) {
      // get existing messages
      fetch(`/room/${roomname}/${text.value}`)
        .then((r) => r.json())
        .then((d) => console.log(d));
      socket.emit("public_message", text.value, roomname);
      text.value = "";
    }
  };

  // append li to chatbox
  socket.on("send_it", (msg, name) => {
    let li = document.createElement("li");
    li.classList.add("list-item");
    // once the li is created, text-align start/end based off of receiver/sender respectively
    !sameSender ? li.classList.add("left") : li.classList.add("right");
    sameSender = false;
    li.textContent = li.classList.contains("right")
      ? msg + ` [${name}]`
      : `[${name}] ` + msg;
    chatbox.appendChild(li);
  });
</script>
